/*
 * langfuse
 *
 * ## Authentication  Authenticate with the API using [Basic Auth](https://en.wikipedia.org/wiki/Basic_access_authentication), get API keys in the project settings:  - username: Langfuse Public Key - password: Langfuse Secret Key  ## Exports  - OpenAPI spec: https://cloud.langfuse.com/generated/api/openapi.yml - Postman collection: https://cloud.langfuse.com/generated/postman/collection.json
 *
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using FileParameter = Langfuse.Client.Client.FileParameter;
using OpenAPIDateConverter = Langfuse.Client.Client.OpenAPIDateConverter;

namespace Langfuse.Client.Model
{
    /// <summary>
    /// Model definition used for transforming usage into USD cost and/or tokenization.
    /// </summary>
    [DataContract(Name = "Model")]
    public partial class LfModel : IValidatableObject
    {

        /// <summary>
        /// Gets or Sets Unit
        /// </summary>
        [DataMember(Name = "unit", EmitDefaultValue = false)]
        public LfModelUsageUnit? Unit { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="LfModel" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected LfModel() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="LfModel" /> class.
        /// </summary>
        /// <param name="id">id (required).</param>
        /// <param name="modelName">Name of the model definition. If multiple with the same name exist, they are applied in the following order: (1) custom over built-in, (2) newest according to startTime where model.startTime&lt;observation.startTime (required).</param>
        /// <param name="matchPattern">Regex pattern which matches this model definition to generation.model. Useful in case of fine-tuned models. If you want to exact match, use &#x60;(?i)^modelname$&#x60; (required).</param>
        /// <param name="startDate">Apply only to generations which are newer than this ISO date..</param>
        /// <param name="unit">unit.</param>
        /// <param name="inputPrice">Deprecated. See &#39;prices&#39; instead. Price (USD) per input unit.</param>
        /// <param name="outputPrice">Deprecated. See &#39;prices&#39; instead. Price (USD) per output unit.</param>
        /// <param name="totalPrice">Deprecated. See &#39;prices&#39; instead. Price (USD) per total unit. Cannot be set if input or output price is set..</param>
        /// <param name="tokenizerId">Optional. Tokenizer to be applied to observations which match to this model. See docs for more details..</param>
        /// <param name="tokenizerConfig">Optional. Configuration for the selected tokenizer. Needs to be JSON. See docs for more details..</param>
        /// <param name="isLangfuseManaged">isLangfuseManaged (required).</param>
        /// <param name="prices">Price (USD) by usage type (required).</param>
        public LfModel(string id = default, string modelName = default, string matchPattern = default, DateTime? startDate = default, LfModelUsageUnit? unit = default, double? inputPrice = default, double? outputPrice = default, double? totalPrice = default, string tokenizerId = default, Object tokenizerConfig = default, bool isLangfuseManaged = default, Dictionary<string, LfModelPrice> prices = default)
        {
            // to ensure "id" is required (not null)
            if (id == null)
            {
                throw new ArgumentNullException("id is a required property for LfModel and cannot be null");
            }
            this.Id = id;
            // to ensure "modelName" is required (not null)
            if (modelName == null)
            {
                throw new ArgumentNullException("modelName is a required property for LfModel and cannot be null");
            }
            this.ModelName = modelName;
            // to ensure "matchPattern" is required (not null)
            if (matchPattern == null)
            {
                throw new ArgumentNullException("matchPattern is a required property for LfModel and cannot be null");
            }
            this.MatchPattern = matchPattern;
            this.IsLangfuseManaged = isLangfuseManaged;
            // to ensure "prices" is required (not null)
            if (prices == null)
            {
                throw new ArgumentNullException("prices is a required property for LfModel and cannot be null");
            }
            this.Prices = prices;
            this.StartDate = startDate;
            this.Unit = unit;
            this.InputPrice = inputPrice;
            this.OutputPrice = outputPrice;
            this.TotalPrice = totalPrice;
            this.TokenizerId = tokenizerId;
            this.TokenizerConfig = tokenizerConfig;
        }

        /// <summary>
        /// Gets or Sets Id
        /// </summary>
        [DataMember(Name = "id", IsRequired = true, EmitDefaultValue = true)]
        public string Id { get; set; }

        /// <summary>
        /// Name of the model definition. If multiple with the same name exist, they are applied in the following order: (1) custom over built-in, (2) newest according to startTime where model.startTime&lt;observation.startTime
        /// </summary>
        /// <value>Name of the model definition. If multiple with the same name exist, they are applied in the following order: (1) custom over built-in, (2) newest according to startTime where model.startTime&lt;observation.startTime</value>
        [DataMember(Name = "modelName", IsRequired = true, EmitDefaultValue = true)]
        public string ModelName { get; set; }

        /// <summary>
        /// Regex pattern which matches this model definition to generation.model. Useful in case of fine-tuned models. If you want to exact match, use &#x60;(?i)^modelname$&#x60;
        /// </summary>
        /// <value>Regex pattern which matches this model definition to generation.model. Useful in case of fine-tuned models. If you want to exact match, use &#x60;(?i)^modelname$&#x60;</value>
        [DataMember(Name = "matchPattern", IsRequired = true, EmitDefaultValue = true)]
        public string MatchPattern { get; set; }

        /// <summary>
        /// Apply only to generations which are newer than this ISO date.
        /// </summary>
        /// <value>Apply only to generations which are newer than this ISO date.</value>
        [DataMember(Name = "startDate", EmitDefaultValue = true)]
        public DateTime? StartDate { get; set; }

        /// <summary>
        /// Deprecated. See &#39;prices&#39; instead. Price (USD) per input unit
        /// </summary>
        /// <value>Deprecated. See &#39;prices&#39; instead. Price (USD) per input unit</value>
        [DataMember(Name = "inputPrice", EmitDefaultValue = true)]
        public double? InputPrice { get; set; }

        /// <summary>
        /// Deprecated. See &#39;prices&#39; instead. Price (USD) per output unit
        /// </summary>
        /// <value>Deprecated. See &#39;prices&#39; instead. Price (USD) per output unit</value>
        [DataMember(Name = "outputPrice", EmitDefaultValue = true)]
        public double? OutputPrice { get; set; }

        /// <summary>
        /// Deprecated. See &#39;prices&#39; instead. Price (USD) per total unit. Cannot be set if input or output price is set.
        /// </summary>
        /// <value>Deprecated. See &#39;prices&#39; instead. Price (USD) per total unit. Cannot be set if input or output price is set.</value>
        [DataMember(Name = "totalPrice", EmitDefaultValue = true)]
        public double? TotalPrice { get; set; }

        /// <summary>
        /// Optional. Tokenizer to be applied to observations which match to this model. See docs for more details.
        /// </summary>
        /// <value>Optional. Tokenizer to be applied to observations which match to this model. See docs for more details.</value>
        [DataMember(Name = "tokenizerId", EmitDefaultValue = true)]
        public string TokenizerId { get; set; }

        /// <summary>
        /// Optional. Configuration for the selected tokenizer. Needs to be JSON. See docs for more details.
        /// </summary>
        /// <value>Optional. Configuration for the selected tokenizer. Needs to be JSON. See docs for more details.</value>
        [DataMember(Name = "tokenizerConfig", EmitDefaultValue = true)]
        public Object TokenizerConfig { get; set; }

        /// <summary>
        /// Gets or Sets IsLangfuseManaged
        /// </summary>
        [DataMember(Name = "isLangfuseManaged", IsRequired = true, EmitDefaultValue = true)]
        public bool IsLangfuseManaged { get; set; }

        /// <summary>
        /// Price (USD) by usage type
        /// </summary>
        /// <value>Price (USD) by usage type</value>
        [DataMember(Name = "prices", IsRequired = true, EmitDefaultValue = true)]
        public Dictionary<string, LfModelPrice> Prices { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class LfModel {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  ModelName: ").Append(ModelName).Append("\n");
            sb.Append("  MatchPattern: ").Append(MatchPattern).Append("\n");
            sb.Append("  StartDate: ").Append(StartDate).Append("\n");
            sb.Append("  Unit: ").Append(Unit).Append("\n");
            sb.Append("  InputPrice: ").Append(InputPrice).Append("\n");
            sb.Append("  OutputPrice: ").Append(OutputPrice).Append("\n");
            sb.Append("  TotalPrice: ").Append(TotalPrice).Append("\n");
            sb.Append("  TokenizerId: ").Append(TokenizerId).Append("\n");
            sb.Append("  TokenizerConfig: ").Append(TokenizerConfig).Append("\n");
            sb.Append("  IsLangfuseManaged: ").Append(IsLangfuseManaged).Append("\n");
            sb.Append("  Prices: ").Append(Prices).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
